"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldUseFlatConfig = exports.updateSchematicDefaults = exports.updateSchematicCollections = exports.determineTargetProjectName = exports.sortObjectByKeys = exports.createESLintConfigForProject = exports.createStringifiedRootESLintConfig = exports.createRootESLintConfig = exports.visitNotIgnoredFiles = exports.addESLintTargetToProject = exports.getTargetsConfigFromProject = exports.updateJsonInTree = exports.readJsonInTree = void 0;
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const ignore_1 = __importDefault(require("ignore"));
const semver_1 = __importDefault(require("semver"));
const strip_json_comments_1 = __importDefault(require("strip-json-comments"));
const devkit_imports_1 = require("./devkit-imports");
const DEFAULT_PREFIX = 'app';
/**
 * This method is specifically for reading JSON files in a Tree
 * @param host The host tree
 * @param path The path to the JSON file
 * @returns The JSON data in the file.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function readJsonInTree(host, path) {
    if (!host.exists(path)) {
        throw new Error(`Cannot find ${path}`);
    }
    const contents = (0, strip_json_comments_1.default)(host.read(path).toString('utf-8'));
    try {
        return JSON.parse(contents);
    }
    catch (e) {
        throw new Error(`Cannot parse ${path}: ${e instanceof Error ? e.message : ''}`);
    }
}
exports.readJsonInTree = readJsonInTree;
/**
 * This method is specifically for updating JSON in a Tree
 * @param path Path of JSON file in the Tree
 * @param callback Manipulation of the JSON data
 * @returns A rule which updates a JSON file file in a Tree
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function updateJsonInTree(path, callback) {
    return (host, context) => {
        if (!host.exists(path)) {
            host.create(path, serializeJson(callback({}, context)));
            return host;
        }
        host.overwrite(path, serializeJson(callback(readJsonInTree(host, path), context)));
        return host;
    };
}
exports.updateJsonInTree = updateJsonInTree;
function getTargetsConfigFromProject(projectConfig) {
    if (!projectConfig) {
        return null;
    }
    if (projectConfig.architect) {
        return projectConfig.architect;
    }
    // "targets" is an undocumented but supported alias of "architect"
    if (projectConfig.targets) {
        return projectConfig.targets;
    }
    return null;
}
exports.getTargetsConfigFromProject = getTargetsConfigFromProject;
function serializeJson(json) {
    return `${JSON.stringify(json, null, 2)}\n`;
}
function readProjectConfiguration(tree, projectName) {
    const angularJSON = (0, devkit_imports_1.readJson)(tree, 'angular.json');
    return angularJSON.projects[projectName];
}
function updateProjectConfiguration(tree, projectName, projectConfig) {
    const angularJSON = (0, devkit_imports_1.readJson)(tree, 'angular.json');
    angularJSON.projects[projectName] = projectConfig;
    (0, devkit_imports_1.writeJson)(tree, 'angular.json', angularJSON);
}
function addESLintTargetToProject(tree, projectName, targetName) {
    const existingProjectConfig = readProjectConfiguration(tree, projectName);
    let lintFilePatternsRoot = '';
    // Default Angular CLI project at the root of the workspace
    if (existingProjectConfig.root === '') {
        lintFilePatternsRoot = existingProjectConfig.sourceRoot || 'src';
    }
    else {
        lintFilePatternsRoot = existingProjectConfig.root;
    }
    const eslintTargetConfig = {
        builder: '@angular-eslint/builder:lint',
        options: {
            lintFilePatterns: [
                `${lintFilePatternsRoot}/**/*.ts`,
                `${lintFilePatternsRoot}/**/*.html`,
            ],
        },
    };
    let eslintConfig;
    if (existingProjectConfig.root !== '') {
        const flatConfigPath = (0, core_1.join)(existingProjectConfig.root, 'eslint.config.js');
        if (tree.exists(flatConfigPath)) {
            eslintConfig = flatConfigPath;
        }
    }
    eslintTargetConfig.options.eslintConfig = eslintConfig;
    existingProjectConfig.architect = existingProjectConfig.architect || {};
    existingProjectConfig.architect[targetName] = eslintTargetConfig;
    updateProjectConfiguration(tree, projectName, existingProjectConfig);
}
exports.addESLintTargetToProject = addESLintTargetToProject;
/**
 * Utility to act on all files in a tree that are not ignored by git.
 */
function visitNotIgnoredFiles(visitor, dir = (0, core_1.normalize)('')) {
    return (host, context) => {
        let ig;
        if (host.exists('.gitignore')) {
            ig = (0, ignore_1.default)();
            ig.add(host.read('.gitignore').toString());
        }
        function visit(_dir) {
            if (_dir && ig?.ignores(_dir)) {
                return;
            }
            const dirEntry = host.getDir(_dir);
            dirEntry.subfiles.forEach((file) => {
                if (ig?.ignores((0, core_1.join)(_dir, file))) {
                    return;
                }
                const maybeRule = visitor((0, core_1.join)(_dir, file), host, context);
                if (maybeRule) {
                    (0, schematics_1.callRule)(maybeRule, host, context).subscribe();
                }
            });
            dirEntry.subdirs.forEach((subdir) => {
                visit((0, core_1.join)(_dir, subdir));
            });
        }
        visit(dir);
    };
}
exports.visitNotIgnoredFiles = visitNotIgnoredFiles;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function setESLintProjectBasedOnProjectType(projectRoot, projectType, hasE2e) {
    let project;
    if (projectType === 'application') {
        project = [`${projectRoot}/tsconfig.(app|spec).json`];
        if (hasE2e) {
            project.push(`${projectRoot}/e2e/tsconfig.json`);
        }
    }
    // Libraries don't have an e2e directory
    if (projectType === 'library') {
        project = [`${projectRoot}/tsconfig.(lib|spec).json`];
    }
    return project;
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function createRootESLintConfig(prefix) {
    let codeRules;
    if (prefix) {
        codeRules = {
            '@angular-eslint/directive-selector': [
                'error',
                { type: 'attribute', prefix, style: 'camelCase' },
            ],
            '@angular-eslint/component-selector': [
                'error',
                { type: 'element', prefix, style: 'kebab-case' },
            ],
        };
    }
    else {
        codeRules = {};
    }
    return {
        root: true,
        ignorePatterns: ['projects/**/*'],
        overrides: [
            {
                files: ['*.ts'],
                extends: [
                    'eslint:recommended',
                    'plugin:@typescript-eslint/recommended',
                    'plugin:@angular-eslint/recommended',
                    'plugin:@angular-eslint/template/process-inline-templates',
                ],
                rules: codeRules,
            },
            {
                files: ['*.html'],
                extends: [
                    'plugin:@angular-eslint/template/recommended',
                    'plugin:@angular-eslint/template/accessibility',
                ],
                rules: {},
            },
        ],
    };
}
exports.createRootESLintConfig = createRootESLintConfig;
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function createStringifiedRootESLintConfig(prefix) {
    return `// @ts-check
const eslint = require("@eslint/js");
const tseslint = require("typescript-eslint");
const angular = require("angular-eslint");
  
module.exports = tseslint.config(
  {
    files: ["**/*.ts"],
    extends: [
      eslint.configs.recommended,
      ...tseslint.configs.recommended,
      ...tseslint.configs.stylistic,
      ...angular.configs.tsRecommended,
    ],
    processor: angular.processInlineTemplates,
    rules: ${prefix
        ? `{
      "@angular-eslint/directive-selector": [
        "error",
        {
          type: "attribute",
          prefix: "${prefix}",
          style: "camelCase",
        },
      ],
      "@angular-eslint/component-selector": [
        "error",
        {
          type: "element",
          prefix: "${prefix}",
          style: "kebab-case",
        },
      ],
    }`
        : '{}'},
  },
  {
    files: ["**/*.html"],
    extends: [
      ...angular.configs.templateRecommended,
      ...angular.configs.templateAccessibility,
    ],
    rules: {},
  }
);
`;
}
exports.createStringifiedRootESLintConfig = createStringifiedRootESLintConfig;
function createProjectESLintConfig(projectRoot, projectType, prefix, setParserOptionsProject, hasE2e) {
    return {
        extends: `${(0, devkit_imports_1.offsetFromRoot)(projectRoot)}.eslintrc.json`,
        ignorePatterns: ['!**/*'],
        overrides: [
            {
                files: ['*.ts'],
                ...(setParserOptionsProject
                    ? {
                        parserOptions: {
                            project: setESLintProjectBasedOnProjectType(projectRoot, projectType, hasE2e),
                        },
                    }
                    : null),
                rules: {
                    '@angular-eslint/directive-selector': [
                        'error',
                        { type: 'attribute', prefix, style: 'camelCase' },
                    ],
                    '@angular-eslint/component-selector': [
                        'error',
                        { type: 'element', prefix, style: 'kebab-case' },
                    ],
                },
            },
            {
                files: ['*.html'],
                rules: {},
            },
        ],
    };
}
function createStringifiedProjectESLintConfig(projectRoot, projectType, prefix, setParserOptionsProject, hasE2e) {
    return `// @ts-check
const tseslint = require("typescript-eslint");
const rootConfig = require("${(0, devkit_imports_1.offsetFromRoot)(projectRoot)}eslint.config.js");

module.exports = tseslint.config(
  ...rootConfig,
  {
    files: ["**/*.ts"],${setParserOptionsProject
        ? `
    languageOptions: {
      parserOptions: {
        projectService: true,
      },
    },`
        : ''}
    rules: {
      "@angular-eslint/directive-selector": [
        "error",
        {
          type: "attribute",
          prefix: "${prefix}",
          style: "camelCase",
        },
      ],
      "@angular-eslint/component-selector": [
        "error",
        {
          type: "element",
          prefix: "${prefix}",
          style: "kebab-case",
        },
      ],
    },
  },
  {
    files: ["**/*.html"],
    rules: {},
  }
);
`;
}
function createESLintConfigForProject(tree, projectName, setParserOptionsProject) {
    const existingProjectConfig = readProjectConfiguration(tree, projectName);
    const targets = existingProjectConfig.architect || existingProjectConfig.targets;
    const { root: projectRoot, projectType, prefix } = existingProjectConfig;
    const hasE2e = !!targets?.e2e;
    const useFlatConfig = shouldUseFlatConfig(tree);
    const alreadyHasRootFlatConfig = tree.exists('eslint.config.js');
    const alreadyHasRootESLintRC = tree.exists('.eslintrc.json');
    /**
     * If the root is an empty string it must be the initial project created at the
     * root by the Angular CLI's workspace schematic
     */
    if (projectRoot === '') {
        return createRootESLintConfigFile(tree, prefix || DEFAULT_PREFIX, useFlatConfig);
    }
    // If, for whatever reason, the root eslint.config.js/.eslintrc.json doesn't exist yet, create it
    if (!alreadyHasRootESLintRC && !alreadyHasRootFlatConfig) {
        createRootESLintConfigFile(tree, prefix || DEFAULT_PREFIX, useFlatConfig);
    }
    if (useFlatConfig) {
        tree.write((0, core_1.join)((0, core_1.normalize)(projectRoot), 'eslint.config.js'), createStringifiedProjectESLintConfig(projectRoot, projectType || 'library', prefix || DEFAULT_PREFIX, setParserOptionsProject, hasE2e));
    }
    else {
        (0, devkit_imports_1.writeJson)(tree, (0, core_1.join)((0, core_1.normalize)(projectRoot), '.eslintrc.json'), createProjectESLintConfig(projectRoot, projectType || 'library', prefix || DEFAULT_PREFIX, setParserOptionsProject, hasE2e));
    }
}
exports.createESLintConfigForProject = createESLintConfigForProject;
function createRootESLintConfigFile(tree, prefix, useFlatConfig) {
    if (useFlatConfig) {
        return tree.write('eslint.config.js', createStringifiedRootESLintConfig(prefix));
    }
    return (0, devkit_imports_1.writeJson)(tree, '.eslintrc.json', createRootESLintConfig(prefix));
}
function sortObjectByKeys(obj) {
    return Object.keys(obj)
        .sort()
        .reduce((result, key) => {
        return {
            ...result,
            [key]: obj[key],
        };
    }, {});
}
exports.sortObjectByKeys = sortObjectByKeys;
/**
 * To make certain schematic usage conversion more ergonomic, if the user does not specify a project
 * and only has a single project in their angular.json we will just go ahead and use that one.
 */
function determineTargetProjectName(tree, maybeProject) {
    if (maybeProject) {
        return maybeProject;
    }
    const workspaceJson = (0, devkit_imports_1.readJson)(tree, 'angular.json');
    const projects = Object.keys(workspaceJson.projects);
    if (projects.length === 1) {
        return projects[0];
    }
    return null;
}
exports.determineTargetProjectName = determineTargetProjectName;
/**
 * See `schematicCollections` docs here:
 * https://github.com/angular/angular-cli/blob/8431b3f0769b5f95b9e13807a09293d820c4b017/docs/specifications/schematic-collections-config.md
 */
function updateSchematicCollections(angularJson) {
    angularJson.cli = angularJson.cli || {};
    angularJson.cli.schematicCollections =
        angularJson.cli.schematicCollections || [];
    // The first matching schematic will be used, so we unshift rather than push
    angularJson.cli.schematicCollections.unshift('@angular-eslint/schematics');
    // Delete old defaultCollection property if applicable
    delete angularJson.cli.defaultCollection;
    return angularJson;
}
exports.updateSchematicCollections = updateSchematicCollections;
function updateSchematicDefaults(angularJson, schematicFullName, defaultValues) {
    angularJson.schematics = angularJson.schematics || {};
    angularJson.schematics[schematicFullName] =
        angularJson.schematics[schematicFullName] || {};
    angularJson.schematics[schematicFullName] = {
        ...angularJson.schematics[schematicFullName],
        ...defaultValues,
    };
    return angularJson;
}
exports.updateSchematicDefaults = updateSchematicDefaults;
/**
 * In order to support both flat config and eslintrc we need to dynamically figure out
 * what the user should be using based on:
 * - their existing files
 * - their eslint version
 */
function shouldUseFlatConfig(tree, existingJson) {
    let useFlatConfig = true;
    try {
        const alreadyHasRootFlatConfig = tree.exists('eslint.config.js');
        const alreadyHasRootESLintRC = tree.exists('.eslintrc.json');
        if (alreadyHasRootFlatConfig) {
            useFlatConfig = true;
        }
        else if (alreadyHasRootESLintRC) {
            useFlatConfig = false;
        }
        else {
            const json = existingJson ??
                JSON.parse(tree.read('package.json').toString('utf-8'));
            json.devDependencies = json.devDependencies || {};
            const existingESLintVersion = json.devDependencies['eslint'];
            if (existingESLintVersion) {
                const v = semver_1.default.minVersion(existingESLintVersion);
                if (v) {
                    useFlatConfig = semver_1.default.gte(v.raw, '9.0.0');
                }
            }
        }
        return useFlatConfig;
    }
    catch {
        return useFlatConfig;
    }
}
exports.shouldUseFlatConfig = shouldUseFlatConfig;
